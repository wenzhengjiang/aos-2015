\documentclass[a4paper,12pt]{article}
\usepackage{pdfpages,cite,hyperref}
\usepackage{natbib}
\usepackage[top=1in, bottom=1.5in,left=1in, right=1in]{geometry}
\setcounter{tocdepth}{2}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{tocloft}
\usepackage{setspace}
\linespread{1}
\setlist{nolistsep}
\setlength\cftparskip{8pt}
\setlength\cftbeforesecskip{1pt}
\setlength\cftaftertoctitleskip{2pt}
\bibliographystyle{agsm}
\hypersetup{colorlinks=true,citecolor=blue,linkcolor=blue,filecolor=blue,urlcolor=blue}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\lhead{}
\fancyfoot[LE,RO]{\slshape \rightmark}
\fancyfoot[LO,RE]{\slshape \leftmark}
\lfoot{}
\rfoot{\thepage}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\refname}{Reference List}
\begin{document}
\renewcommand{\headheight}{15pt}
\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%
\pagenumbering{arabic}
  \begin{center}
    \vspace*{60mm}
    {\Large \bfseries{AOS Group 3 - SOS Design Documentation}}\\[8mm]
    19$^{th}$ October, 2015\\[20mm]
  \end{center}
\newpage
\tableofcontents
\newpage
\section{Overview}
The Simple Operating System, or SOS, performs resource management for
applications running on top of the seL4 Microkernel on ARMv7.  This document
describes the design of SOS as implemented by AOS Group 3.  For each key
design choice in the project, it also discusses benefits and trade-offs of the
decision, and possible alternative approaches.

There are 4 distinct problem-areas that have been explored in SOS: Interrupts
and IPC, Memory, I/O and Process Management.  Interrupts and IPC requests are
essential for all interaction with SOS, and thus offer a solid starting point
for introducing the system architecture from a higher level perspective.

\section{Interrupts and IPC}
\subsection{Concurrency Model}
At its core, SOS uses an event-based model implemented using
\emph{continuations}.  A continuation allows for non-blocking behaviour during
otherwise blocking requests (for example I/O) by providing a way to preserve
execution state.

\subsubsection{Design}
Pertinent files: /apps/sos/src/main.c

TODO: Talk about threads and event-based models, introduce continuations.

A continuation is specific to a process, and is used to track the current
state of execution and allow event handlers to be re-entrant and are thus used
to control side-effects of the execution of fuctions.

A continuation in SOS is a struct which describes the current execution
context.  The struct has many fields, including:

\begin{itemize}
\item the original syscall number
\item the number of re-entries into the syscall handler
\item the number of bytes read or written
\end{itemize}

\subsubsection{Discussion}
TODO: Talk about threads and event-based models

The design of continuation is conceptually simple, and allows for
type-checking at compile-time, which affords some correctness guarantees.
However, this struct becomes exceedingly large as more behaviours are added to
SOS, each of which may depend on and need to extend upon the state already
stored in the continuation.  As this is a per-process structure, it thus
requires an additional frame to be allocated for every process running on the
system, and should more functionality be added to SOS, may require multiple
frames to be allocated causing concerns over contiguous allocation of the
memory backing the structure.

A more scalable approach would be to implement the continuation as an array or
hash table, whereby 32-bit values could be accessed given a key.  The
implication of this is that compile-time type-checking is lost, and that
accesses will often need to be cast.

This may seem a preferable for the reason of scalability, however static
analysis becomes increasingly valuable for offering correctness guarantees as
an Operating System grows.  For this reason it was deemed an inferior approach
to the single, large continuation structure given the scope of the project.

Yet more sophisticated data structures could also be used, which are amenable
to both static analysis, and better scalability, though the added complexity
of managing these data structures exceeded the benefits for the current
incarnation of SOS.

\subsection{Timer Interrupts}
Pertinent files: /libs/libclock/src/clock.c

\subsubsection{Design}
The timer interrupt was implemented using the GPT timer on the Sabre.

The GPT timer allows multiple Output Compare Registers to be set
simultaneously, and thus affords the ability to support two different modes of
behaviour.

\begin{enumerate}
\item Regular 100ms kernel tick
\item Timed callback events
\end{enumerate}

Both timed callbacks and kernel tick callbacks are exposed via an interface
for registering callback functions when these events occur.

All kernel tick callbacks are called with each kernel tick.  Thus the
developer needs to be aware of the execution time required for a kernel tick
callback, and should ensure that this execution time is minimised.

Timed callbacks are called after a timeout expires.  This is implemented by
ensuring that all registrations are ordered at registration-time, and setting
the corresponding Output Compare Register to the next event in the queue.
TODO: How overflow is accounted for.

Timed callbacks are removed after being fired, and thus are excellent
candidates for use in functions such as sleep.  For this reason kernel tick
events is distingiushed from timed callback events.

\subsubsection{Discussion}
Alternatively the EPIT timer could have been used to implement this
functionality.  Both EPIT and GPT timers on the Sabre have a very similar
interface, and both could equally have been used.  However it was elected that
the GPT is slightly simpler and fulfills all requirements.

\subsection{Syscall Handling}
Pertinent files: /apps/sos/src/handler.c, /apps/sos/src/syscall.c

\subsubsection{Design}
As this is a continuation-based model, each syscall is implemented in two
parts: a setup handler, and an execution handler.

The setup handler is called once, at the beginning of a syscall and before the
execution handler is invoked.  This allows a single, consistent means of
storing any arguments provided via IPC within the continuation, so that they
may be available to the execution handler.

The syscall dispatch is respresented as a matrix, whereby the number of
implemented syscalls form the `rows', and function pointers to the setup and
execution handlers form the `columns'.  This gives simple and constant-time
access to the syscalls implemented within SOS: the syscall lookup is an index
into the array based on the syscall number, and the handler to be executed is
also an index.

The dispatch is performed via a single function, which executes the setup
handler should for the desired syscall (should one be defined), storing the
fact that this has been executed in the continuation.  The dispatcher will
then invoke the execution handler for that syscall.

Should the execution of a syscall handler result in an operation which would
otherwise be blocking, execution will return to the syscall loop until an
interrupt occurs based on the completion of the event.

TODO: Discuss callback mechanisms (here or elsewhere)

\subsubsection{Discussion}
TODO: Work out what the scope of this section is/should be and then discuss.

\section{Memory}
\subsection{Page Faults}
Pertinent files: /apps/sos/src/handler.c

\subsubsection{Design}
Page faults within SOS occur in a number of circumstances:
\begin{itemize}
\item When the process attempts to read data, which has been paged to disk, back into memory
\item For lazy-loading data in from an ELF binary
\item Faulting-in new pages within the heap or stack
\item As a means of setting the frame referenced bit for second chance replacement\
\end{itemize}

TODO: Discuss the different events that can occur, and how those are implemented.
\subsubsection{Discussion}


\subsection{Frame Table}
Pertinent files: /apps/sos/src/frametable.c

The frame table is the representation of physical memory. This memory is
mapped by applications and also used by SOSH.  Only frames are represented by
the frametable, with other datatypes residing elsewhere in the system.
\subsubsection{Design}
(todo)Linked array data structure allocated at boot-time.

\subsubsection{Discussion}
We could also have represented other datatypes within the `frame table' and
provided a mapping back to them, though the vast majority of typed memory in
the system is typed as frames, and so the added complexity of managing other
datatypes in the frame table outweighs the minimal benefit it offers.  Instead
memory of types other than smallpageobject(todo:check name) is stored
explictly in other data structures.

\subsection{Page Replacement}
Pertinent files: /apps/sos/src/page\_replacement.c, /apps/sos/src/swap.c

When the frame table is fully allocated, and further attempts to allocate
frames are made, the system begins swapping pages to disk.

\subsubsection{Design}
Swapping occurs in a few stages.
- select the process
- select the page (second chance)
- evict
- read in page on disk (if needed)

\subsubsection{Discussion}

\subsection{Swap File Management}
\subsubsection{Design}
Specialised functions are used for handling the write and read from disk.  We
write to a constant filename `.sos\_swap' over NFS.  swap.c contains functions
dedicated for the management of this file and performing the swapping actions,
while page\_replacement.c controls the process for selecting, evicting and
reading pages and ensuring all internal state remains consistent.

The swap table provides a representation of the state of the swap file.  It is
implemented using an linked array data structure similar to the frame table.
The frame table is used to store the frames required for the swap table.

We do simple checksumming to protect against modification.
\subsection{Discussion}


\section{I/O}
Pertinent files: /apps/sos/src/file.c

\subsection{IO Vectors}
Pertinent files: /apps/sos/src/file.c

A representation of client application or SOS-internal memory regions,
allowing memory to be mapped for I/O on an as-needed basis.

\subsubsection{Design}
An IO Vector provides the following datastructure:

%\begin{table}
%  \begin{tabular}[l|l]
%  \end{tabular}
%\end{table}

\subsubsection{Discussion}
The IO Vector is not a strictly required datastructure: it is an abstraction
over the current state of an I/O operation.  This is an abstraction
particularly useful for our design as NFS driver, which provides for a
significant portion of the total I/O ops of the system, implements callback
semantics.

\subsection{Serial Device}
Pertinent files: /apps/sos/src/serial.c

Single-reader / multiple-writer serial device implementation.

\subsubsection{Design}
reader\_pid
storage and use of reader buffer

\subsubsection{Discussion}


\subsection{NFS}
Pertinent files: /apps/sos/src/sos\_nfs.c

\subsubsection{Design}

\subsubsection{Discussion}

\subsection{IO Device}
\subsubsection{Design}
An IO device is an abstraction over both block and character devices.  In the
case of SOS, this abstracts both Serial and NFS to create a uniform IO
interface through mapping function pointers to their respective
implementations.

\subsubsection{Discussion}
The IO Device is a light-weight mechanism to abstract access to IO-related
drivers.  An alternative to this would be the implementation of a VFS-like
abstraction.  However, given that the goals of the project were to support a
single, flat filesystem, and a serial device, this was deemed an overly
extravagant abstraction.

\section{Process Management}
Pertinent files: /apps/sos/src/process.c, /apps/sos/src/elf.c

\subsection{Page Table}
Pertinent files: /apps/sos/src/addrspace.c

\subsubsection{Design}
2-level page table: 10 bits, 10 bits, 12 bits.
PTEs contain cap, frame addr
lower bits of frame addr used for frame state flags: swapd, refd, pinned.

PTs / PDs mapped in to seL4
\subsubsection{Discussion}
Varying from seL4 implementation: 8/12
Why we did it
How we accounted for implications of that.

\subsection{Regions}
\subsubsection{Design}
Regions are implemented as a linked list.  Each region contains start, end,
rights, and an addr into the elf file.
\subsubsection{Discussion}
There is no optimisation on the lookup cost of a region.  This data structure
is searched in a number of cases, but most importantly, in the event of a VM
Fault.  A binary may have as few as 4 segments mapped in to the address space,
and in this instance the searching cost may be acceptable.  However as the
number of regions increases, the performance of the system may be subject to
significant degradation.

A better approach may be... TODO

\subsection{PID Management}
Pertinent files: /apps/sos/src/process.c

\subsubsection{Design}
Doubly-linked list over an array.
Minimised PID reuse.
Mechanisms for accounting for race condition when PID is reused

\subsubsection{Discussion}
SOS provides a high-performance PID implementation, where PID lookup,
creation, and removal are all constant time operations.

SOS also accounts for a race condition where the association between a
callback may become associated with the incorrect process should the system
have a high utilisation of the available PIDs allowed for the system.


\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
